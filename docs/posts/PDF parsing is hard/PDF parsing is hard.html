<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Safouane Chergui">
<meta name="dcterms.date" content="2025-08-27">

<title>PDF parsing is hard – Safouane Chergui</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Safouane Chergui</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/chsafouane"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/safouane-chergui/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://buymeacoffee.com/chsafouane"> <i class="bi bi-cup-straw" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../sitemap.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">PDF parsing is hard</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Python</div>
                <div class="quarto-category">PDF</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Safouane Chergui </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 27, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-the-hell-is-a-pdf-document" id="toc-what-the-hell-is-a-pdf-document">What the hell is a PDF document ?</a>
  <ul>
  <li><a href="#a-first-glimpse-at-a-pdf-file-internal-structure" id="toc-a-first-glimpse-at-a-pdf-file-internal-structure">A first glimpse at a PDF file internal structure</a></li>
  <li><a href="#pdf-page-description-language" id="toc-pdf-page-description-language">PDF Page Description Language</a></li>
  <li><a href="#the-internal-structure-of-a-pdf" id="toc-the-internal-structure-of-a-pdf">The internal structure of a PDF</a>
  <ul>
  <li><a href="#the-header" id="toc-the-header">The header</a></li>
  <li><a href="#the-body" id="toc-the-body">The body</a></li>
  <li><a href="#the-cross-reference-table" id="toc-the-cross-reference-table">The cross-reference table</a></li>
  <li><a href="#the-trailer" id="toc-the-trailer">The trailer</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#docling-v2" id="toc-docling-v2">Docling V2</a>
  <ul>
  <li><a href="#project-context" id="toc-project-context">Project context</a></li>
  <li><a href="#why-we-went-for-docling" id="toc-why-we-went-for-docling">Why we went for Docling ?</a>
  <ul>
  <li><a href="#the-fast-good-enough-didnt-cut-it" id="toc-the-fast-good-enough-didnt-cut-it">The fast &amp; good enough didn’t cut it!</a></li>
  <li><a href="#ml-focused-parsing" id="toc-ml-focused-parsing">ML-focused parsing</a></li>
  </ul></li>
  <li><a href="#how-does-docling-work" id="toc-how-does-docling-work">How does Docling work ?</a></li>
  <li><a href="#parsing-output" id="toc-parsing-output">Parsing output</a></li>
  <li><a href="#docling-in-practice" id="toc-docling-in-practice">Docling in practice</a></li>
  <li><a href="#explore-more-with-docling" id="toc-explore-more-with-docling">Explore more with Docling!</a></li>
  </ul></li>
  </ul>
</nav>
<p>The goal of this blogpost is to explain what a PDF is internally and why parsing PDF files is not that easy.</p>
<p>Lately, I’ve been working on a project with a customer where the goal is to extract some specific information from PDF documents. To my big surprise, this task has proven to be quite challenging.</p>
<p>The main challenges stem from the following elements:</p>
<ul>
<li><strong>Privacy concerns:</strong> using an external API to parse the PDFs was a no-go as the PDFs contained sensitive information.</li>
<li><strong>Complexity of the documents:</strong> the PDFs at hand contained a mix of text, complex tables, math formulas, all of which needed to be processed and understood in context.</li>
<li><strong>Absence of a clear structure:</strong> the lack of consistent formatting and structure across the documents made it difficult to apply standard parsing across the board.</li>
</ul>
<br><br>
<div data-align="center">
<p><img src="./assets/pdf-icon.png" alt="PDF icon" width="25%" style="display: block; margin: 0 auto;"></p>
</div>
<p><br></p>
<section id="what-the-hell-is-a-pdf-document" class="level2">
<h2 class="anchored" data-anchor-id="what-the-hell-is-a-pdf-document">What the hell is a PDF document ?</h2>
<section id="a-first-glimpse-at-a-pdf-file-internal-structure" class="level3">
<h3 class="anchored" data-anchor-id="a-first-glimpse-at-a-pdf-file-internal-structure">A first glimpse at a PDF file internal structure</h3>
<p>Have you ever opened a PDF document with notepad or vscode instead of your preferred PDF reader ? If you do so , you’ll stumble upon something that looks like this :</p>
<div data-align="center">
<p><img src="./assets/example_pdf_start.png" alt="PDF Internal Structure" style="display: block; margin: 0 auto;"></p>
<p align="center">
<em>Figure 1: Internal structure of a PDF document when viewed as raw text</em>
</p>
</div>
<p>If you’d like to see the full PDF internal structure, you can find the example PDF <a href="https://gist.github.com/chsafouane/0079eb20531a0effb632e9aea7ddfabe?short_path=b320036">here</a>.</p>
</section>
<section id="pdf-page-description-language" class="level3">
<h3 class="anchored" data-anchor-id="pdf-page-description-language">PDF Page Description Language</h3>
<p>To understand why PDFs are hard to parse, one must understand how a PDF file is built.</p>
<p>A PDF file is based on Page Description Language (PDL), which is a language used to describe the layout and appearance of a printed page. PDF PDL provides a standardized set of commands to reconstruct a page with perfect fidelity.</p>
<p>As a result, a PDF file is essentially a collection of instructions for rendering a page, rather than a linear sequence of text and images. If you look at the example pdf available in the github gist, you’ll see starting line 34 the following commands:</p>
<pre class="pdf"><code>/F1 18 Tf
100 700 Td
(This is a PDF tutorial) Tj</code></pre>
<p>What the following instructions do is:</p>
<ul>
<li><code>/F1 18 Tf</code> : set the font to F1 with size 18</li>
<li><code>100 700 Td</code> : move the text position to (100, 700)</li>
<li><code>(This is a PDF tutorial) Tj</code> : show the text string</li>
</ul>
<p>Every PDF looks just like this; a precise sequence of commands that specify what to draw and exactly at what coordinates. It does not contain a semantic representation of its content. It does not state, “This is a paragraph that flows through two columns” or “this is a table”.</p>
<p>A table, for example, is just a grid of lines and text positioned at specific coordinates. There are no inherent relationships between the cells, no indication of headers or footers, and no understanding of the data contained within.</p>
<p>So when a parser sees what’s supposed to be a table, it sees just a bunch of lines and text. Its task (rather difficult task) is to infer the structure and relationships between these elements.</p>
<p>This lack of semantic structure makes it challenging to parse complex PDF documents.</p>
</section>
<section id="the-internal-structure-of-a-pdf" class="level3">
<h3 class="anchored" data-anchor-id="the-internal-structure-of-a-pdf">The internal structure of a PDF</h3>
<p>This is an optional part and will not help you in understanding the difficulty of parsing PDFs. So you can skip if you want to focus on the practical aspects of PDF parsing.</p>
<p>What you see in Figure 1 or in the gist file is the internal structure of a PDF document. Let us dive into the key components that make up this structure.</p>
<p>A PDF is composed internally of four sections:</p>
<div data-align="center">
<p><img src="./assets/pdf_internal_structure.png" alt="PDF Internal Structure Components" style="display: block; margin: 0 auto;"></p>
<p align="center">
<em>Figure 2: Internal structure of a PDF document</em>
</p>
<p align="center">
<small>Source: <a href="https://www.researchgate.net/figure/An-example-of-the-PDF-file-structure_fig1_360275035">ResearchGate - An example of the PDF file structure</a></small>
</p>
</div>
<section id="the-header" class="level4">
<h4 class="anchored" data-anchor-id="the-header">The header</h4>
<p>The header of a PDF file tells you about the PDF specifications version used to generate it. It is always the first line of the file and starts with the <code>%PDF-</code> marker. In Figure 1, it corresponds to <code>%PDF-1.7</code>.</p>
</section>
<section id="the-body" class="level4">
<h4 class="anchored" data-anchor-id="the-body">The body</h4>
<p>Now, the body is where you define the content of the PDF. Everything that you see when you open a PDF - the text you read, the images you view, the fonts that make the text look pretty - all of this is generated from the “objects” defined in the body.</p>
<p>Think about when you open a PDF and scroll through it. You might see different pages, each with its own layout, fonts, and content. Behind the scenes, each of these elements is stored as a separate object in the PDF body.</p>
<p>If you look at the PDF file in the gist, you’ll see that it contains 5 objects. Each object in a PDF is identified by a unique object number and a generation number (usually 0 for new objects).</p>
</section>
<section id="the-cross-reference-table" class="level4">
<h4 class="anchored" data-anchor-id="the-cross-reference-table">The cross-reference table</h4>
<p>Now, here’s where the magic happens that makes PDFs so fast to navigate. You know how you can instantly jump to page 50 of a 200-page PDF, or how quickly a PDF opens even when it’s a large file? That’s thanks to the cross-reference table (or “xref table”).</p>
<p>The xref table maps object numbers to their byte positions in the file. Here’s the one from our sample PDF:</p>
<pre class="pdf"><code>xref
0 6
0000000000 65535 f 
0000000017 00000 n 
0000000070 00000 n 
0000000126 00000 n 
0000000281 00000 n 
0000000385 00000 n </code></pre>
<p>Let me break this down:</p>
<ul>
<li><code>xref</code> marks the start of the cross-reference table</li>
<li><code>0 6</code> means this section covers 6 objects starting from object 0</li>
<li>Each line has three parts: <code>byte_offset generation_number n/f</code>
<ul>
<li><strong>Byte offset</strong>: The exact position in the file where the object starts (like a street address)</li>
<li><strong>Generation number</strong>: Usually 0 for active objects</li>
<li><strong>n/f flag</strong>: <code>n</code> means the object is in use, <code>f</code> means it’s free (deleted)</li>
</ul></li>
</ul>
<p>The generation number and the n/f flag are useful when the PDF is modified.</p>
<p>For example, when you want to see the page content, the PDF reader looks up object 4 (content stream) in this table, sees it at byte position 281, jumps directly there, and gets the drawing commands. No searching, no scanning, just instant access.</p>
<p>This is why PDFs load so quickly even when they’re huge files. Your PDF viewer doesn’t have to read the whole document.</p>
</section>
<section id="the-trailer" class="level4">
<h4 class="anchored" data-anchor-id="the-trailer">The trailer</h4>
<p>Finally, we have the trailer - think of it as the PDF’s “instruction manual” that tells your PDF viewer how to get started. When you double-click a PDF file to open it, your PDF reader doesn’t start reading from the beginning. Instead, it jumps to the end of the file and reads the trailer first.</p>
<p>Here’s the trailer from our sample PDF:</p>
<pre class="pdf"><code>trailer
&lt;&lt; /Size 6
/Root 1 0 R
&gt;&gt;
startxref
449
%%EOF</code></pre>
<p>Here’s what happens when you open a PDF:</p>
<ul>
<li><strong><code>/Size 6</code></strong>: The PDF reader learns there are 6 objects total in the cross-reference table</li>
<li><strong><code>/Root 1 0 R</code></strong>: “Start reading from the catalog object (object 1) to understand the document structure”</li>
<li><strong><code>startxref 449</code></strong>: “The cross-reference table starts at byte position 449”</li>
<li><strong><code>%%EOF</code></strong>: “This is truly the end of the file”</li>
</ul>
<p>So when you open a PDF, here’s the process: 1. Your PDF reader jumps to the end and reads the trailer 2. From the trailer, it gets to know that the xref table is at position 449 and reads it to understand where all objects are 3. When you scroll or jump to a page, it uses the xref table to instantly find the right objects</p>
<p>This four-part structure (header, body, xref, trailer) is what makes PDFs very fast to read no matter their size.</p>
</section>
</section>
</section>
<section id="docling-v2" class="level2">
<h2 class="anchored" data-anchor-id="docling-v2">Docling V2</h2>
<div data-align="center">
<p><img src="./assets/docling_logo.png" alt="Docling Logo" width="50%" style="display: block; margin: 0 auto;"></p>
</div>
<section id="project-context" class="level3">
<h3 class="anchored" data-anchor-id="project-context">Project context</h3>
<p>So, here are the main constraints of the project: - It had some high privacy concerns. This means that using an external API for PDF parsing was not an option. - The PDFs were very complex. They contained a mix of text and really complex tables, math formulas, etc. - The customer preferred to run the workload of PDF parsing on their on-premise infrastructure that didn’t provide any GPU.</p>
<p>The point that was to our advantage is that the incoming documents didn’t need to be processed online. Batch processing of documents was sufficient, and we could afford to take our time with the parsing.</p>
</section>
<section id="why-we-went-for-docling" class="level3">
<h3 class="anchored" data-anchor-id="why-we-went-for-docling">Why we went for Docling ?</h3>
<section id="the-fast-good-enough-didnt-cut-it" class="level4">
<h4 class="anchored" data-anchor-id="the-fast-good-enough-didnt-cut-it">The fast &amp; good enough didn’t cut it!</h4>
<p>While I used to go with <code>PyMuPDF</code> for PDF parsing because it’s easy to use, fast, and good enough for PDF with text and simple tables, it did a really bad job on the documents that we had to handle. The tables were very badly parsed.</p>
<p>To preserve the speed advantage, I decided to use a combination of <code>PyMuPDF</code> for the initial text extraction and a library dedicated to table extraction like <code>tabula</code> or <code>camelot</code>. Not only did this approach add more dependencies and more complexity, <code>tabula</code> and <code>camelot</code> both did a very bad job at extracting most tables.</p>
<p>Now, these packages look at the PDF instructions (like the ones shown in the PDL section) and try to reverse-engineer the layout of the document. While this makes for fast parsing, they have a hard time parsing a two-column layout accurately or a complex table. A good way to put it is that they have a hard time looking at things a human does.</p>
<p><code>camelot</code> and <code>tabula</code> both rely on heuristics and rules that work well for simple well-structured tables.</p>
</section>
<section id="ml-focused-parsing" class="level4">
<h4 class="anchored" data-anchor-id="ml-focused-parsing">ML-focused parsing</h4>
<p>ML-focused parsing usually make use of: - a parsing engine to parse text - Some layout detection model to detect the different object in the page (e.g.&nbsp;headers, text blocks, images, tables, etc.) - Some table analysis model - Some post-processing steps to combine all the results together</p>
<p>We benchmarked <code>unstructured</code> and <code>docling</code> and found that <code>docling</code> was doing a better job at parsing the documents we had to handle.</p>
<p><strong>Note:</strong> I didn’t test unstructured API which seems to offer more functionalities than the open-source package.</p>
</section>
</section>
<section id="how-does-docling-work" class="level3">
<h3 class="anchored" data-anchor-id="how-does-docling-work">How does Docling work ?</h3>
<p>Docling uses a combination of techniques to parse PDF documents effectively:</p>
<ol type="1">
<li><p><strong>Text Extraction</strong>: Initially, it extracts text from the PDF using a fast and efficient text extraction engine.</p></li>
<li><p><strong>Layout Detection</strong>: It employs a layout detection model to identify different elements on the page, such as titles, text, images, tables, etc.</p></li>
<li><p><strong>Table Analysis</strong>: For detected tables, Docling uses a specialized table analysis model to understand the structure and content of the table cells.</p></li>
<li><p><strong>OCR</strong>: Optionally, one can activate OCR if handling scanned documents.</p></li>
<li><p><strong>Assembly</strong>: Finally, it applies post-processing steps to combine all the extracted information and present it in a structured format in <code>DoclingDocument</code>.</p></li>
</ol>
<p>The resulting object <code>DoclingDocument</code> is not a simple text string. It is a hierarchical representation of the original document, containing organized lists of items defined in Docling (<code>TextItem</code>, <code>PictureItem</code>, etc.). Each of these objects holds its content, coordinates, type, and relationships to other elements.</p>
<p>Please refer to the <a href="https://docling-project.github.io/docling/concepts/docling_document/">Docling documentation</a> for more details on the structure and usage of <code>DoclingDocument</code>.</p>
</section>
<section id="parsing-output" class="level3">
<h3 class="anchored" data-anchor-id="parsing-output">Parsing output</h3>
<p>On top of the docling document that contains anything you can imagine, you can convert the docling document to a a simple string or to a markdown. You can also extract tables as pandas dataframes wich is really very handy.</p>
</section>
<section id="docling-in-practice" class="level3">
<h3 class="anchored" data-anchor-id="docling-in-practice">Docling in practice</h3>
<p>We used docling on french documents. A document made of more or less 60 pages, between 5 or 10 tables takes between 60 and 90 seconds using Docling.</p>
<p>As a parsing output</p>
<p>The things that didn’t work that well include: - tables that roll over two pages. In my experience, Docling considers them as separate tables - multicolumn text is rarely but sometimes is considered a table</p>
</section>
<section id="explore-more-with-docling" class="level3">
<h3 class="anchored" data-anchor-id="explore-more-with-docling">Explore more with Docling!</h3>
<ul>
<li>Docling can be used to parse many types of documents like powerpoint docs, word docs, html docs, PDFs and more.</li>
</ul>
<div data-align="center">
<p><img src="./assets/docling_processing.png" alt="Docling Processing" style="display: block; margin: 0 auto;"></p>
</div>
<p><br><br> - Docling is also designed to be used seamlessly with RAG and supports functionalities like chunking documents. - More recent packages in the docling family of packages are:</p>
<ul>
<li><a href="https://github.com/docling-project/docling-serve"><code>docling-serve</code></a>: The FastAPI wrappers for running Docling as REST API and distribute large jobs.</li>
<li><a href="https://github.com/docling-project/docling-sdg"><code>docling-sdg</code></a>: Synthetic data generation (SDG) on documents for dataset generation for RAG, finetuning, etc.</li>
<li><a href="https://github.com/docling-project/docling-mcp"><code>docling-mcp</code></a>: The definition of tools with the Model Context Protocol for document conversion, manipulation and generation agents.</li>
</ul>
<p>While I didn’t try these three packages, I’m looking forward to it.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/chsafouane\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>